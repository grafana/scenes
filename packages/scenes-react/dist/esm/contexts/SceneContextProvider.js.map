{"version":3,"file":"SceneContextProvider.js","sources":["../../../src/contexts/SceneContextProvider.tsx"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState } from 'react';\nimport { SceneTimeRangeState, SceneTimeRange, behaviors, UrlSyncContextProvider } from '@grafana/scenes';\n\nimport { SceneContextObject, SceneContextObjectState } from './SceneContextObject';\n\nexport const SceneContext = createContext<SceneContextObject | null>(null);\n\nexport interface SceneContextProviderProps {\n  /**\n   * Only the initial time range, cannot be used to update time range\n   **/\n  timeRange?: Partial<SceneTimeRangeState>;\n  /**\n   *  This makes it possbile to view running state of queries via\n   *  refresh picker and also cancel all queries in the scene.\n   */\n  withQueryController?: boolean;\n  /**\n   * Children\n   */\n  children: React.ReactNode;\n}\n\n/**\n * Wrapps the react children in a SceneContext\n */\nexport function SceneContextProvider({ children, timeRange, withQueryController }: SceneContextProviderProps) {\n  const parentContext = useContext(SceneContext);\n  const [childContext, setChildContext] = useState<SceneContextObject | undefined>();\n\n  // Becasue timeRange is not part of useEffect dependencies\n  const initialTimeRange = timeRange;\n\n  useEffect(() => {\n    const state: SceneContextObjectState = { children: [] };\n\n    if (withQueryController) {\n      state.$behaviors = [new behaviors.SceneQueryController()];\n    }\n\n    if (initialTimeRange) {\n      state.$timeRange = new SceneTimeRange(initialTimeRange);\n    }\n\n    const childContext = new SceneContextObject(state);\n\n    if (parentContext) {\n      parentContext.addChildContext(childContext);\n    }\n\n    const deactivate = childContext.activate();\n    setChildContext(childContext);\n\n    return () => {\n      deactivate();\n\n      if (parentContext) {\n        parentContext.removeChildContext(childContext);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [parentContext, withQueryController]);\n\n  if (!childContext) {\n    return null;\n  }\n\n  const innerProvider = <SceneContext.Provider value={childContext}>{children}</SceneContext.Provider>;\n\n  if (parentContext) {\n    return innerProvider;\n  }\n\n  // For root context we wrap the provider in a UrlSyncWrapper that handles the hook that updates state on location changes\n  return (\n    <UrlSyncContextProvider scene={childContext} updateUrlOnInit={true} createBrowserHistorySteps={true}>\n      {innerProvider}\n    </UrlSyncContextProvider>\n  );\n}\n"],"names":["childContext"],"mappings":";;;;AAKa,MAAA,YAAA,GAAe,cAAyC,IAAI,EAAA;AAqBlE,SAAS,oBAAqB,CAAA,EAAE,QAAU,EAAA,SAAA,EAAW,qBAAkD,EAAA;AAC5G,EAAM,MAAA,aAAA,GAAgB,WAAW,YAAY,CAAA,CAAA;AAC7C,EAAA,MAAM,CAAC,YAAA,EAAc,eAAe,CAAA,GAAI,QAAyC,EAAA,CAAA;AAGjF,EAAA,MAAM,gBAAmB,GAAA,SAAA,CAAA;AAEzB,EAAA,SAAA,CAAU,MAAM;AACd,IAAA,MAAM,KAAiC,GAAA,EAAE,QAAU,EAAA,EAAG,EAAA,CAAA;AAEtD,IAAA,IAAI,mBAAqB,EAAA;AACvB,MAAA,KAAA,CAAM,UAAa,GAAA,CAAC,IAAI,SAAA,CAAU,sBAAsB,CAAA,CAAA;AAAA,KAC1D;AAEA,IAAA,IAAI,gBAAkB,EAAA;AACpB,MAAM,KAAA,CAAA,UAAA,GAAa,IAAI,cAAA,CAAe,gBAAgB,CAAA,CAAA;AAAA,KACxD;AAEA,IAAMA,MAAAA,aAAAA,GAAe,IAAI,kBAAA,CAAmB,KAAK,CAAA,CAAA;AAEjD,IAAA,IAAI,aAAe,EAAA;AACjB,MAAA,aAAA,CAAc,gBAAgBA,aAAY,CAAA,CAAA;AAAA,KAC5C;AAEA,IAAM,MAAA,UAAA,GAAaA,cAAa,QAAS,EAAA,CAAA;AACzC,IAAA,eAAA,CAAgBA,aAAY,CAAA,CAAA;AAE5B,IAAA,OAAO,MAAM;AACX,MAAW,UAAA,EAAA,CAAA;AAEX,MAAA,IAAI,aAAe,EAAA;AACjB,QAAA,aAAA,CAAc,mBAAmBA,aAAY,CAAA,CAAA;AAAA,OAC/C;AAAA,KACF,CAAA;AAAA,GAEC,EAAA,CAAC,aAAe,EAAA,mBAAmB,CAAC,CAAA,CAAA;AAEvC,EAAA,IAAI,CAAC,YAAc,EAAA;AACjB,IAAO,OAAA,IAAA,CAAA;AAAA,GACT;AAEA,EAAM,MAAA,aAAA,mBAAiB,KAAA,CAAA,aAAA,CAAA,YAAA,CAAa,QAAb,EAAA;AAAA,IAAsB,KAAO,EAAA,YAAA;AAAA,GAAA,EAAe,QAAS,CAAA,CAAA;AAE5E,EAAA,IAAI,aAAe,EAAA;AACjB,IAAO,OAAA,aAAA,CAAA;AAAA,GACT;AAGA,EAAA,uBACG,KAAA,CAAA,aAAA,CAAA,sBAAA,EAAA;AAAA,IAAuB,KAAO,EAAA,YAAA;AAAA,IAAc,eAAiB,EAAA,IAAA;AAAA,IAAM,yBAA2B,EAAA,IAAA;AAAA,GAAA,EAC5F,aACH,CAAA,CAAA;AAEJ;;;;"}