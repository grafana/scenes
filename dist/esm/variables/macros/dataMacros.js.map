{"version":3,"file":"dataMacros.js","sources":["../../../../src/variables/macros/dataMacros.ts"],"sourcesContent":["import {\n  FieldType,\n  formattedValueToString,\n  getDisplayProcessor,\n  ScopedVars,\n  DataContextScopedVar,\n  getFieldDisplayValuesProxy,\n  getFrameDisplayName,\n} from '@grafana/data';\nimport { SceneObject } from '../../core/types';\nimport { getFieldAccessor } from '../interpolation/fieldAccessorCache';\nimport { FormatVariable } from '../interpolation/formatRegistry';\nimport { VariableValue } from '../types';\nimport { getTemplateProxyForField } from './templateProxies';\n\n/**\n * This macro handles the ${__value.*} interpolation\n * match represents the regex match and is the full expression, example `${varname.fieldpath}`\n * Macros can return the match when they identify that there required data context is not provided.\n * This leaves the expression intact so that it can be interpolated later when the data context is available.\n */\nexport class ValueMacro implements FormatVariable {\n  public state: { name: string; type: string };\n\n  public constructor(name: string, sceneObject: SceneObject, private _match: string, private _scopedVars?: ScopedVars) {\n    this.state = { name, type: '__value' };\n  }\n\n  public getValue(fieldPath?: string): VariableValue {\n    const dataContext: DataContextScopedVar | undefined = this._scopedVars?.__dataContext;\n    if (!dataContext) {\n      return this._match;\n    }\n\n    const { frame, rowIndex, field, calculatedValue } = dataContext.value;\n\n    if (calculatedValue) {\n      switch (fieldPath) {\n        case 'numeric':\n          return calculatedValue.numeric;\n        case 'raw':\n          return calculatedValue.numeric;\n        case 'time':\n          return '';\n        case 'text':\n        default:\n          return formattedValueToString(calculatedValue);\n      }\n    }\n\n    if (rowIndex == null) {\n      return this._match;\n    }\n\n    if (fieldPath === 'time') {\n      const timeField = frame.fields.find((f) => f.type === FieldType.time);\n      return timeField ? timeField.values.get(rowIndex) : undefined;\n    }\n\n    if (!field) {\n      return this._match;\n    }\n\n    const value = field.values.get(rowIndex);\n    if (fieldPath === 'raw') {\n      return value;\n    }\n\n    const displayProcessor = field.display ?? fallbackDisplayProcessor;\n    const result = displayProcessor(value);\n\n    switch (fieldPath) {\n      case 'numeric':\n        return result.numeric;\n      case 'text':\n      default:\n        return formattedValueToString(result);\n    }\n  }\n\n  public getValueText?(): string {\n    return '';\n  }\n}\n\nconst fallbackDisplayProcessor = getDisplayProcessor();\n\n/**\n * This macro handles the ${__data.*} interpolation. This is a bit poorly named as most of the\n * expressions that this macro evaluates are really \"row\" based values enabling you to access\n * values in other fields on the same row.\n */\nexport class DataMacro implements FormatVariable {\n  public state: { name: string; type: string };\n\n  public constructor(name: string, sceneObject: SceneObject, private _match: string, private _scopedVars?: ScopedVars) {\n    this.state = { name, type: '__data' };\n  }\n\n  public getValue(fieldPath?: string): VariableValue {\n    const dataContext = this._scopedVars?.__dataContext;\n    if (!dataContext || !fieldPath) {\n      return this._match;\n    }\n\n    const { frame, rowIndex } = dataContext.value;\n\n    if (rowIndex === undefined || fieldPath === undefined) {\n      return this._match;\n    }\n\n    const obj = {\n      name: frame.name,\n      refId: frame.refId,\n      fields: getFieldDisplayValuesProxy({ frame, rowIndex }),\n    };\n\n    return getFieldAccessor(fieldPath)(obj) ?? '';\n  }\n\n  public getValueText?(): string {\n    return '';\n  }\n}\n\n/**\n * This macro handles the ${__series.name} interpolation.\n */\nexport class SeriesMacro implements FormatVariable {\n  public state: { name: string; type: string };\n\n  public constructor(name: string, sceneObject: SceneObject, private _match: string, private _scopedVars?: ScopedVars) {\n    this.state = { name, type: '__series' };\n  }\n\n  public getValue(fieldPath?: string): VariableValue {\n    const dataContext = this._scopedVars?.__dataContext;\n    if (!dataContext || !fieldPath) {\n      return this._match;\n    }\n\n    if (fieldPath !== 'name') {\n      return this._match;\n    }\n\n    const { frame, frameIndex } = dataContext.value;\n    return getFrameDisplayName(frame, frameIndex);\n  }\n\n  public getValueText?(): string {\n    return '';\n  }\n}\n\n/**\n * This macro handles the ${__field.*} interpolation. These do not require a data context.\n * And can be easily used in field config options like displayName.\n */\nexport class FieldMacro implements FormatVariable {\n  public state: { name: string; type: string };\n\n  public constructor(name: string, sceneObject: SceneObject, private _match: string, private _scopedVars?: ScopedVars) {\n    this.state = { name, type: '__field' };\n  }\n\n  public getValue(fieldPath?: string): VariableValue {\n    const dataContext = this._scopedVars?.__dataContext;\n    if (!dataContext || !fieldPath) {\n      return this._match;\n    }\n\n    if (fieldPath === undefined || fieldPath === '') {\n      return this._match;\n    }\n\n    const { frame, field, data } = dataContext.value;\n    const obj = getTemplateProxyForField(field, frame, data);\n\n    return getFieldAccessor(fieldPath)(obj) ?? '';\n  }\n\n  public getValueText?(): string {\n    return '';\n  }\n}\n"],"names":[],"mappings":"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"}