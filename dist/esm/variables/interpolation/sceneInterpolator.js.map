{"version":3,"file":"sceneInterpolator.js","sources":["../../../../src/variables/interpolation/sceneInterpolator.ts"],"sourcesContent":["import { ScopedVars } from '@grafana/data';\nimport { VariableInterpolation } from '@grafana/runtime';\nimport { VariableType, VariableFormatID } from '@grafana/schema';\n\nimport { SceneObject } from '../../core/types';\nimport { InterpolationFormatParameter, isCustomVariableValue, VariableValue } from '../types';\n\nimport { getSceneVariableForScopedVar } from './ScopedVarsVariable';\nimport { formatRegistry, FormatVariable } from './formatRegistry';\nimport { VARIABLE_REGEX } from '../constants';\nimport { lookupVariable } from '../lookupVariable';\nimport { macrosIndex } from '../macros';\n\n/**\n * This function will try to parse and replace any variable expression found in the target string. The sceneObject will be used as the source of variables. It will\n * use the scene graph and walk up the parent tree until it finds the closest variable.\n *\n * ScopedVars should not really be needed much in the new scene architecture as they can be added to the local scene node instead of passed in interpolate function.\n * It is supported here for backward compatibility and some edge cases where adding scoped vars to local scene node is not practical.\n */\nexport function sceneInterpolator(\n  sceneObject: SceneObject,\n  target: string | undefined | null,\n  scopedVars?: ScopedVars,\n  format?: InterpolationFormatParameter,\n  interpolations?: VariableInterpolation[]\n): string {\n  if (!target || typeof target !== 'string') {\n    return target ?? '';\n  }\n\n  VARIABLE_REGEX.lastIndex = 0;\n\n  return target.replace(VARIABLE_REGEX, (match, var1, var2, fmt2, var3, fieldPath, fmt3) => {\n    const variableName = var1 || var2 || var3;\n    const fmt = fmt2 || fmt3 || format;\n    const variable = lookupFormatVariable(variableName, match, scopedVars, sceneObject);\n\n    if (!variable) {\n      if (interpolations) {\n        // Set `value` equal to `match` as documented in the `VariableInterpolation` interface.\n        interpolations.push({ match, variableName, fieldPath, format: fmt, value: match, found: false });\n      }\n      return match;\n    }\n\n    const value = formatValue(sceneObject, variable, variable.getValue(fieldPath), fmt);\n\n    if (interpolations) {\n      interpolations.push({ match, variableName, fieldPath, format: fmt, value, found: value !== match });\n    }\n\n    return value;\n  });\n}\n\nfunction lookupFormatVariable(\n  name: string,\n  match: string,\n  scopedVars: ScopedVars | undefined,\n  sceneObject: SceneObject\n): FormatVariable | null {\n  if (scopedVars && scopedVars.hasOwnProperty(name)) {\n    const scopedVar = scopedVars[name];\n\n    if (scopedVar) {\n      return getSceneVariableForScopedVar(name, scopedVar);\n    }\n  }\n\n  const variable = lookupVariable(name, sceneObject);\n  if (variable) {\n    return variable;\n  }\n\n  const Macro = macrosIndex.get(name);\n  if (Macro) {\n    return new Macro(name, sceneObject, match, scopedVars);\n  }\n\n  return null;\n}\n\nfunction formatValue(\n  context: SceneObject,\n  variable: FormatVariable,\n  value: VariableValue | undefined | null,\n  formatNameOrFn?: InterpolationFormatParameter\n): string {\n  if (value === null || value === undefined) {\n    return '';\n  }\n\n  // Variable can return a custom value that handles formatting\n  // This is useful for customAllValue and macros that return values that are already formatted or need special formatting\n  if (isCustomVariableValue(value)) {\n    return sceneInterpolator(context, value.formatter(formatNameOrFn));\n  }\n\n  // if it's an object transform value to string\n  if (!Array.isArray(value) && typeof value === 'object') {\n    value = `${value}`;\n  }\n\n  if (typeof formatNameOrFn === 'function') {\n    return formatNameOrFn(value, {\n      name: variable.state.name,\n      type: variable.state.type as VariableType,\n      multi: variable.state.isMulti,\n      includeAll: variable.state.includeAll,\n    });\n  }\n\n  let args: string[] = [];\n\n  if (!formatNameOrFn) {\n    formatNameOrFn = VariableFormatID.Glob;\n  } else {\n    // some formats have arguments that come after ':' character\n    args = formatNameOrFn.split(':');\n    if (args.length > 1) {\n      formatNameOrFn = args[0];\n      args = args.slice(1);\n    } else {\n      args = [];\n    }\n  }\n\n  let formatter = formatRegistry.getIfExists(formatNameOrFn);\n\n  if (!formatter) {\n    console.error(`Variable format ${formatNameOrFn} not found. Using glob format as fallback.`);\n    formatter = formatRegistry.get(VariableFormatID.Glob);\n  }\n\n  return formatter.formatter(value, args, variable);\n}\n"],"names":[],"mappings":"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"}