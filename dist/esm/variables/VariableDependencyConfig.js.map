{"version":3,"file":"VariableDependencyConfig.js","sources":["../../../src/variables/VariableDependencyConfig.ts"],"sourcesContent":["import { DataLinkBuiltInVars } from '@grafana/data';\nimport { sceneGraph } from '../core/sceneGraph';\nimport { SceneObject, SceneObjectState } from '../core/types';\nimport { writeSceneLog } from '../utils/writeSceneLog';\nimport { VARIABLE_REGEX } from './constants';\n\nimport { SceneVariable, SceneVariableDependencyConfigLike } from './types';\nimport { safeStringifyValue } from './utils';\n\ninterface VariableDependencyConfigOptions<TState extends SceneObjectState> {\n  /**\n   * State paths to scan / extract variable dependencies from. Leave empty to scan all paths.\n   */\n  statePaths?: Array<keyof TState | '*'>;\n\n  /**\n   * Explicit list of variable names to depend on. Leave empty to scan state for dependencies.\n   */\n  variableNames?: string[];\n\n  /**\n   * Optional way to customize how to handle when a dependent variable changes\n   * If not specified the default behavior is to trigger a re-render\n   */\n  onReferencedVariableValueChanged?: (variable: SceneVariable) => void;\n\n  /**\n   * Two scenarios trigger this callback to be called.\n   * 1. When any direct dependency changed value\n   * 2. In case hasDependencyInLoadingState was called and returned true we really care about any variable update. So in this scenario this callback is called\n   *    after any variable update completes. This is to cover scenarios where an object is waiting for indirect dependencies to complete.\n   */\n  onVariableUpdateCompleted?: () => void;\n\n  /**\n   * Optional way to subscribe to all variable value changes, even to variables that are not dependencies.\n   */\n  onAnyVariableChanged?: (variable: SceneVariable) => void;\n}\n\nexport class VariableDependencyConfig<TState extends SceneObjectState> implements SceneVariableDependencyConfigLike {\n  private _state: TState | undefined;\n  private _dependencies = new Set<string>();\n  private _statePaths?: Array<keyof TState | '*'>;\n  private _isWaitingForVariables = false;\n\n  public scanCount = 0;\n\n  public constructor(\n    private _sceneObject: SceneObject<TState>,\n    private _options: VariableDependencyConfigOptions<TState>\n  ) {\n    this._statePaths = _options.statePaths;\n  }\n\n  /**\n   * Used to check for dependency on a specific variable\n   */\n  public hasDependencyOn(name: string): boolean {\n    return this.getNames().has(name);\n  }\n\n  /**\n   * This is called whenever any set of variables have new values. It is up to this implementation to check if it's relevant given the current dependencies.\n   */\n  public variableUpdateCompleted(variable: SceneVariable, hasChanged: boolean) {\n    const deps = this.getNames();\n    let dependencyChanged = false;\n\n    if ((deps.has(variable.state.name) || deps.has(DataLinkBuiltInVars.includeVars)) && hasChanged) {\n      dependencyChanged = true;\n    }\n\n    writeSceneLog(\n      'VariableDependencyConfig',\n      'variableUpdateCompleted',\n      variable.state.name,\n      dependencyChanged,\n      this._isWaitingForVariables\n    );\n\n    if (this._options.onAnyVariableChanged) {\n      this._options.onAnyVariableChanged(variable);\n    }\n\n    // If custom handler called when dependency is changed or when we are waiting for variables\n    if (this._options.onVariableUpdateCompleted && (this._isWaitingForVariables || dependencyChanged)) {\n      this._options.onVariableUpdateCompleted();\n    }\n\n    if (dependencyChanged) {\n      if (this._options.onReferencedVariableValueChanged) {\n        this._options.onReferencedVariableValueChanged(variable);\n      }\n\n      // if no callbacks are specified then just do a forceRender\n      if (!this._options.onReferencedVariableValueChanged && !this._options.onVariableUpdateCompleted) {\n        this._sceneObject.forceRender();\n      }\n    }\n  }\n\n  public hasDependencyInLoadingState() {\n    if (sceneGraph.hasVariableDependencyInLoadingState(this._sceneObject)) {\n      this._isWaitingForVariables = true;\n      return true;\n    }\n\n    this._isWaitingForVariables = false;\n    return false;\n  }\n\n  public getNames(): Set<string> {\n    const prevState = this._state;\n    const newState = (this._state = this._sceneObject.state);\n\n    if (!prevState) {\n      // First time we always scan for dependencies\n      this.scanStateForDependencies(this._state);\n      return this._dependencies;\n    }\n\n    // Second time we only scan if state is a different and if any specific state path has changed\n    if (newState !== prevState) {\n      if (this._statePaths) {\n        for (const path of this._statePaths) {\n          if (path === '*' || newState[path] !== prevState[path]) {\n            this.scanStateForDependencies(newState);\n            break;\n          }\n        }\n      } else {\n        this.scanStateForDependencies(newState);\n      }\n    }\n\n    return this._dependencies;\n  }\n\n  /**\n   * Update variableNames\n   */\n  public setVariableNames(varNames: string[]) {\n    this._options.variableNames = varNames;\n    this.scanStateForDependencies(this._state!);\n  }\n\n  public setPaths(paths: Array<keyof TState | '*'>) {\n    this._statePaths = paths;\n  }\n\n  private scanStateForDependencies(state: TState) {\n    this._dependencies.clear();\n    this.scanCount += 1;\n\n    if (this._options.variableNames) {\n      for (const name of this._options.variableNames) {\n        this._dependencies.add(name);\n      }\n    }\n\n    if (this._statePaths) {\n      for (const path of this._statePaths) {\n        if (path === '*') {\n          this.extractVariablesFrom(state);\n          break;\n        } else {\n          const value = state[path];\n          if (value) {\n            this.extractVariablesFrom(value);\n          }\n        }\n      }\n    }\n  }\n\n  private extractVariablesFrom(value: unknown) {\n    VARIABLE_REGEX.lastIndex = 0;\n\n    const stringToCheck = typeof value !== 'string' ? safeStringifyValue(value) : value;\n\n    const matches = stringToCheck.matchAll(VARIABLE_REGEX);\n    if (!matches) {\n      return;\n    }\n\n    for (const match of matches) {\n      const [, var1, var2, , var3] = match;\n      const variableName = var1 || var2 || var3;\n      this._dependencies.add(variableName);\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;AAwCO,MAAM,wBAAuG,CAAA;AAAA,EAQ3G,WAAA,CACG,cACA,QACR,EAAA;AAFQ,IAAA,IAAA,CAAA,YAAA,GAAA,YAAA,CAAA;AACA,IAAA,IAAA,CAAA,QAAA,GAAA,QAAA,CAAA;AARV,IAAQ,IAAA,CAAA,aAAA,uBAAoB,GAAY,EAAA,CAAA;AAExC,IAAA,IAAA,CAAQ,sBAAyB,GAAA,KAAA,CAAA;AAEjC,IAAA,IAAA,CAAO,SAAY,GAAA,CAAA,CAAA;AAMjB,IAAA,IAAA,CAAK,cAAc,QAAS,CAAA,UAAA,CAAA;AAAA,GAC9B;AAAA,EAKO,gBAAgB,IAAuB,EAAA;AAC5C,IAAA,OAAO,IAAK,CAAA,QAAA,EAAW,CAAA,GAAA,CAAI,IAAI,CAAA,CAAA;AAAA,GACjC;AAAA,EAKO,uBAAA,CAAwB,UAAyB,UAAqB,EAAA;AAC3E,IAAM,MAAA,IAAA,GAAO,KAAK,QAAS,EAAA,CAAA;AAC3B,IAAA,IAAI,iBAAoB,GAAA,KAAA,CAAA;AAExB,IAAK,IAAA,CAAA,IAAA,CAAK,GAAI,CAAA,QAAA,CAAS,KAAM,CAAA,IAAI,CAAK,IAAA,IAAA,CAAK,GAAI,CAAA,mBAAA,CAAoB,WAAW,CAAA,KAAM,UAAY,EAAA;AAC9F,MAAoB,iBAAA,GAAA,IAAA,CAAA;AAAA,KACtB;AAEA,IAAA,aAAA;AAAA,MACE,0BAAA;AAAA,MACA,yBAAA;AAAA,MACA,SAAS,KAAM,CAAA,IAAA;AAAA,MACf,iBAAA;AAAA,MACA,IAAK,CAAA,sBAAA;AAAA,KACP,CAAA;AAEA,IAAI,IAAA,IAAA,CAAK,SAAS,oBAAsB,EAAA;AACtC,MAAK,IAAA,CAAA,QAAA,CAAS,qBAAqB,QAAQ,CAAA,CAAA;AAAA,KAC7C;AAGA,IAAA,IAAI,IAAK,CAAA,QAAA,CAAS,yBAA8B,KAAA,IAAA,CAAK,0BAA0B,iBAAoB,CAAA,EAAA;AACjG,MAAA,IAAA,CAAK,SAAS,yBAA0B,EAAA,CAAA;AAAA,KAC1C;AAEA,IAAA,IAAI,iBAAmB,EAAA;AACrB,MAAI,IAAA,IAAA,CAAK,SAAS,gCAAkC,EAAA;AAClD,QAAK,IAAA,CAAA,QAAA,CAAS,iCAAiC,QAAQ,CAAA,CAAA;AAAA,OACzD;AAGA,MAAA,IAAI,CAAC,IAAK,CAAA,QAAA,CAAS,oCAAoC,CAAC,IAAA,CAAK,SAAS,yBAA2B,EAAA;AAC/F,QAAA,IAAA,CAAK,aAAa,WAAY,EAAA,CAAA;AAAA,OAChC;AAAA,KACF;AAAA,GACF;AAAA,EAEO,2BAA8B,GAAA;AACnC,IAAA,IAAI,UAAW,CAAA,mCAAA,CAAoC,IAAK,CAAA,YAAY,CAAG,EAAA;AACrE,MAAA,IAAA,CAAK,sBAAyB,GAAA,IAAA,CAAA;AAC9B,MAAO,OAAA,IAAA,CAAA;AAAA,KACT;AAEA,IAAA,IAAA,CAAK,sBAAyB,GAAA,KAAA,CAAA;AAC9B,IAAO,OAAA,KAAA,CAAA;AAAA,GACT;AAAA,EAEO,QAAwB,GAAA;AAC7B,IAAA,MAAM,YAAY,IAAK,CAAA,MAAA,CAAA;AACvB,IAAA,MAAM,QAAY,GAAA,IAAA,CAAK,MAAS,GAAA,IAAA,CAAK,YAAa,CAAA,KAAA,CAAA;AAElD,IAAA,IAAI,CAAC,SAAW,EAAA;AAEd,MAAK,IAAA,CAAA,wBAAA,CAAyB,KAAK,MAAM,CAAA,CAAA;AACzC,MAAA,OAAO,IAAK,CAAA,aAAA,CAAA;AAAA,KACd;AAGA,IAAA,IAAI,aAAa,SAAW,EAAA;AAC1B,MAAA,IAAI,KAAK,WAAa,EAAA;AACpB,QAAW,KAAA,MAAA,IAAA,IAAQ,KAAK,WAAa,EAAA;AACnC,UAAA,IAAI,IAAS,KAAA,GAAA,IAAO,QAAS,CAAA,IAAA,CAAA,KAAU,UAAU,IAAO,CAAA,EAAA;AACtD,YAAA,IAAA,CAAK,yBAAyB,QAAQ,CAAA,CAAA;AACtC,YAAA,MAAA;AAAA,WACF;AAAA,SACF;AAAA,OACK,MAAA;AACL,QAAA,IAAA,CAAK,yBAAyB,QAAQ,CAAA,CAAA;AAAA,OACxC;AAAA,KACF;AAEA,IAAA,OAAO,IAAK,CAAA,aAAA,CAAA;AAAA,GACd;AAAA,EAKO,iBAAiB,QAAoB,EAAA;AAC1C,IAAA,IAAA,CAAK,SAAS,aAAgB,GAAA,QAAA,CAAA;AAC9B,IAAK,IAAA,CAAA,wBAAA,CAAyB,KAAK,MAAO,CAAA,CAAA;AAAA,GAC5C;AAAA,EAEO,SAAS,KAAkC,EAAA;AAChD,IAAA,IAAA,CAAK,WAAc,GAAA,KAAA,CAAA;AAAA,GACrB;AAAA,EAEQ,yBAAyB,KAAe,EAAA;AAC9C,IAAA,IAAA,CAAK,cAAc,KAAM,EAAA,CAAA;AACzB,IAAA,IAAA,CAAK,SAAa,IAAA,CAAA,CAAA;AAElB,IAAI,IAAA,IAAA,CAAK,SAAS,aAAe,EAAA;AAC/B,MAAW,KAAA,MAAA,IAAA,IAAQ,IAAK,CAAA,QAAA,CAAS,aAAe,EAAA;AAC9C,QAAK,IAAA,CAAA,aAAA,CAAc,IAAI,IAAI,CAAA,CAAA;AAAA,OAC7B;AAAA,KACF;AAEA,IAAA,IAAI,KAAK,WAAa,EAAA;AACpB,MAAW,KAAA,MAAA,IAAA,IAAQ,KAAK,WAAa,EAAA;AACnC,QAAA,IAAI,SAAS,GAAK,EAAA;AAChB,UAAA,IAAA,CAAK,qBAAqB,KAAK,CAAA,CAAA;AAC/B,UAAA,MAAA;AAAA,SACK,MAAA;AACL,UAAA,MAAM,QAAQ,KAAM,CAAA,IAAA,CAAA,CAAA;AACpB,UAAA,IAAI,KAAO,EAAA;AACT,YAAA,IAAA,CAAK,qBAAqB,KAAK,CAAA,CAAA;AAAA,WACjC;AAAA,SACF;AAAA,OACF;AAAA,KACF;AAAA,GACF;AAAA,EAEQ,qBAAqB,KAAgB,EAAA;AAC3C,IAAA,cAAA,CAAe,SAAY,GAAA,CAAA,CAAA;AAE3B,IAAA,MAAM,gBAAgB,OAAO,KAAA,KAAU,QAAW,GAAA,kBAAA,CAAmB,KAAK,CAAI,GAAA,KAAA,CAAA;AAE9E,IAAM,MAAA,OAAA,GAAU,aAAc,CAAA,QAAA,CAAS,cAAc,CAAA,CAAA;AACrD,IAAA,IAAI,CAAC,OAAS,EAAA;AACZ,MAAA,OAAA;AAAA,KACF;AAEA,IAAA,KAAA,MAAW,SAAS,OAAS,EAAA;AAC3B,MAAA,MAAM,GAAG,IAAA,EAAM,IAAM,IAAE,IAAI,CAAI,GAAA,KAAA,CAAA;AAC/B,MAAM,MAAA,YAAA,GAAe,QAAQ,IAAQ,IAAA,IAAA,CAAA;AACrC,MAAK,IAAA,CAAA,aAAA,CAAc,IAAI,YAAY,CAAA,CAAA;AAAA,KACrC;AAAA,GACF;AACF;;;;"}