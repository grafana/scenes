{"version":3,"file":"SceneQueryRunner.js","sources":["../../../src/querying/SceneQueryRunner.ts"],"sourcesContent":["import { cloneDeep, isEqual } from 'lodash';\nimport { forkJoin, ReplaySubject, Unsubscribable } from 'rxjs';\n\nimport { DataQuery, DataSourceRef, LoadingState } from '@grafana/schema';\n\nimport {\n  AlertStateInfo,\n  DataFrame,\n  DataFrameView,\n  DataQueryRequest,\n  DataSourceApi,\n  DataTopic,\n  PanelData,\n  preProcessPanelData,\n  rangeUtil,\n} from '@grafana/data';\n\n// TODO: Remove this ignore annotation when the grafana runtime dependency has been updated\n// @ts-ignore\nimport { getRunRequest, toDataQueryError, isExpressionReference, config } from '@grafana/runtime';\n\nimport { SceneObjectBase } from '../core/SceneObjectBase';\nimport { sceneGraph } from '../core/sceneGraph';\nimport {\n  DataLayerFilter,\n  SceneDataProvider,\n  SceneDataProviderResult,\n  SceneDataQuery,\n  SceneObjectState,\n  SceneTimeRangeLike,\n} from '../core/types';\nimport { getDataSource } from '../utils/getDataSource';\nimport { VariableDependencyConfig } from '../variables/VariableDependencyConfig';\nimport { writeSceneLog } from '../utils/writeSceneLog';\nimport { VariableValueRecorder } from '../variables/VariableValueRecorder';\nimport { emptyPanelData } from '../core/SceneDataNode';\nimport { getClosest } from '../core/sceneGraph/utils';\nimport { isExtraQueryProvider, ExtraQueryDataProcessor, ExtraQueryProvider } from './ExtraQueryProvider';\nimport { passthroughProcessor, extraQueryProcessingOperator } from './extraQueryProcessingOperator';\nimport { filterAnnotations } from './layers/annotations/filterAnnotations';\nimport { getEnrichedDataRequest } from './getEnrichedDataRequest';\nimport { findActiveAdHocFilterVariableByUid } from '../variables/adhoc/patchGetAdhocFilters';\nimport { registerQueryWithController } from './registerQueryWithController';\nimport { findActiveGroupByVariablesByUid } from '../variables/groupby/findActiveGroupByVariablesByUid';\nimport { GroupByVariable } from '../variables/groupby/GroupByVariable';\nimport { AdHocFiltersVariable, isFilterComplete } from '../variables/adhoc/AdHocFiltersVariable';\nimport { SceneVariable } from '../variables/types';\nimport { DataLayersMerger } from './DataLayersMerger';\nimport { interpolate } from '../core/sceneGraph/sceneGraph';\nimport { wrapInSafeSerializableSceneObject } from '../utils/wrapInSafeSerializableSceneObject';\n\nlet counter = 100;\n\nexport function getNextRequestId() {\n  return 'SQR' + counter++;\n}\n\nexport interface QueryRunnerState extends SceneObjectState {\n  data?: PanelData;\n  queries: SceneDataQuery[];\n  datasource?: DataSourceRef;\n  minInterval?: string;\n  maxDataPoints?: number;\n  liveStreaming?: boolean;\n  maxDataPointsFromWidth?: boolean;\n  cacheTimeout?: DataQueryRequest['cacheTimeout'];\n  queryCachingTTL?: DataQueryRequest['queryCachingTTL'];\n  /**\n   * When set to auto (the default) query runner will issue queries on activate (when variable dependencies are ready) or when time range change.\n   * Set to manual to have full manual control over when queries are issued. Try not to set this. This is mainly useful for unit tests, or special edge case workflows.\n   */\n  runQueriesMode?: 'auto' | 'manual';\n  // Filters to be applied to data layer results before combining them with SQR results\n  dataLayerFilter?: DataLayerFilter;\n  // Private runtime state\n  _hasFetchedData?: boolean;\n}\n\nexport interface DataQueryExtended extends DataQuery {\n  [key: string]: any;\n\n  // Opt this query out of time window comparison\n  timeRangeCompare?: boolean;\n}\n\n// The requests that will be run by the query runner.\n//\n// Generally the query runner will run a single primary request.\n// If the scene graph contains implementations of\n// `ExtraQueryProvider`, the requests created by these\n// implementations will be added to the list of secondary requests,\n// and these will be executed at the same time as the primary request.\n//\n// The results of each secondary request will be passed to an associated\n// processor function (along with the results of the primary request),\n// which can transform the results as desired.\ninterface PreparedRequests {\n  // The primary request to run.\n  primary: DataQueryRequest;\n  // A possibly empty list of secondary requests to run alongside\n  // the primary request.\n  secondaries: DataQueryRequest[];\n  // A map from `requestId` of secondary requests to processors\n  // for those requests. Provided by the `ExtraQueryProvider`.\n  processors: Map<string, ExtraQueryDataProcessor>;\n}\n\nexport class SceneQueryRunner extends SceneObjectBase<QueryRunnerState> implements SceneDataProvider {\n  private _querySub?: Unsubscribable;\n  private _dataLayersSub?: Unsubscribable;\n  private _dataLayersMerger = new DataLayersMerger();\n  private _timeSub?: Unsubscribable;\n  private _timeSubRange?: SceneTimeRangeLike;\n  private _containerWidth?: number;\n  private _variableValueRecorder = new VariableValueRecorder();\n  private _results = new ReplaySubject<SceneDataProviderResult>(1);\n  private _scopedVars = { __sceneObject: wrapInSafeSerializableSceneObject(this) };\n  private _layerAnnotations?: DataFrame[];\n  private _resultAnnotations?: DataFrame[];\n\n  private _adhocFiltersVar?: AdHocFiltersVariable;\n  private _groupByVar?: GroupByVariable;\n\n  public getResultsStream() {\n    return this._results;\n  }\n\n  protected _variableDependency: VariableDependencyConfig<QueryRunnerState> = new VariableDependencyConfig(this, {\n    statePaths: ['queries', 'datasource'],\n    onVariableUpdateCompleted: this.onVariableUpdatesCompleted.bind(this),\n    onAnyVariableChanged: this.onAnyVariableChanged.bind(this),\n  });\n\n  public constructor(initialState: QueryRunnerState) {\n    super(initialState);\n\n    this.addActivationHandler(() => this._onActivate());\n  }\n\n  private _onActivate() {\n    if (this.isQueryModeAuto()) {\n      const timeRange = sceneGraph.getTimeRange(this);\n\n      // Add subscriptions to any extra providers so that they rerun queries\n      // when their state changes and they should rerun.\n      const providers = this.getClosestExtraQueryProviders();\n      for (const provider of providers) {\n        this._subs.add(\n          provider.subscribeToState((n, p) => {\n            if (provider.shouldRerun(p, n, this.state.queries)) {\n              this.runQueries();\n            }\n          }),\n        );\n      }\n\n      this.subscribeToTimeRangeChanges(\n        timeRange,\n      );\n\n      if (this.shouldRunQueriesOnActivate()) {\n        this.runQueries();\n      }\n    }\n\n    if (!this._dataLayersSub) {\n      this._handleDataLayers();\n    }\n\n    return () => this._onDeactivate();\n  }\n\n  // This method subscribes to all SceneDataLayers up until the root, and combines the results into data provided from SceneQueryRunner\n  private _handleDataLayers() {\n    const dataLayers = sceneGraph.getDataLayers(this);\n\n    if (dataLayers.length === 0) {\n      return;\n    }\n\n    this._dataLayersSub = this._dataLayersMerger\n      .getMergedStream(dataLayers)\n      .subscribe(this._onLayersReceived.bind(this));\n  }\n\n  private _onLayersReceived(results: Iterable<SceneDataProviderResult>) {\n    const timeRange = sceneGraph.getTimeRange(this);\n    const { dataLayerFilter } = this.state;\n\n    let annotations: DataFrame[] = [];\n    let alertStates: DataFrame[] = [];\n    let alertState: AlertStateInfo | undefined;\n\n    for (const result of results) {\n      for (let frame of result.data.series) {\n        if (frame.meta?.dataTopic === DataTopic.Annotations) {\n          annotations = annotations.concat(frame);\n        }\n        if (frame.meta?.dataTopic === DataTopic.AlertStates) {\n          alertStates = alertStates.concat(frame);\n        }\n      }\n    }\n\n    if (dataLayerFilter?.panelId) {\n      if (annotations.length > 0) {\n        annotations = filterAnnotations(annotations, dataLayerFilter);\n      }\n\n      if (alertStates.length > 0) {\n        for (const frame of alertStates) {\n          const frameView = new DataFrameView<AlertStateInfo>(frame);\n\n          for (const row of frameView) {\n            if (row.panelId === dataLayerFilter.panelId) {\n              alertState = row;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // Skip unnessary state updates\n    if (\n      allFramesEmpty(annotations) &&\n      allFramesEmpty(this._layerAnnotations) &&\n      isEqual(alertState, this.state.data?.alertState)\n    ) {\n      return;\n    }\n\n    this._layerAnnotations = annotations;\n\n    const baseStateUpdate = this.state.data ? this.state.data : { ...emptyPanelData, timeRange: timeRange.state.value };\n\n    this.setState({\n      data: {\n        ...baseStateUpdate,\n        annotations: [...(this._resultAnnotations ?? []), ...annotations],\n        alertState: alertState ?? this.state.data?.alertState,\n      },\n    });\n  }\n\n  /**\n   * This tries to start a new query whenever a variable completes or is changed.\n   *\n   * We care about variable update completions even when the variable has not changed and even when it is not a direct dependency.\n   * Example: Variables A and B (B depends on A). A update depends on time range. So when time change query runner will\n   * find that variable A is loading which is a dependency on of variable B so will set _isWaitingForVariables to true and\n   * not issue any query.\n   *\n   * When A completes it's loading (with no value change, so B never updates) it will cause a call of this function letting\n   * the query runner know that A has completed, and in case _isWaitingForVariables we try to run the query. The query will\n   * only run if all variables are in a non loading state so in other scenarios where a query depends on many variables this will\n   * be called many times until all dependencies are in a non loading state.   *\n   */\n  private onVariableUpdatesCompleted() {\n    if(this.isQueryModeAuto()){\n      this.runQueries();\n    }\n  }\n\n  /**\n   * Check if value changed is a adhoc filter o group by variable that did not exist when we issued the last query\n   */\n  private onAnyVariableChanged(variable: SceneVariable) {\n    // If this variable has already been detected this variable as a dependency onVariableUpdatesCompleted above will handle value changes\n    if (this._adhocFiltersVar === variable || this._groupByVar === variable || !this.isQueryModeAuto()) {\n      return;\n    }\n\n    if (variable instanceof AdHocFiltersVariable && this._isRelevantAutoVariable(variable)) {\n      this.runQueries();\n    }\n\n    if (variable instanceof GroupByVariable && this._isRelevantAutoVariable(variable)) {\n      this.runQueries();\n    }\n  }\n\n  private _isRelevantAutoVariable(variable: AdHocFiltersVariable | GroupByVariable) {\n    const datasource = this.state.datasource ?? findFirstDatasource(this.state.queries);\n    return variable.state.applyMode === 'auto' && datasource?.uid === variable.state.datasource?.uid;\n  }\n\n  private shouldRunQueriesOnActivate() {\n    if (this._variableValueRecorder.hasDependenciesChanged(this)) {\n      writeSceneLog(\n        'SceneQueryRunner',\n        'Variable dependency changed while inactive, shouldRunQueriesOnActivate returns true'\n      );\n      return true;\n    }\n\n    // If we don't have any data we should run queries\n    if (!this.state.data) {\n      return true;\n    }\n\n    // If time range is stale / different we should run queries\n    if (this._isDataTimeRangeStale(this.state.data)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private _isDataTimeRangeStale(data: PanelData) {\n    const timeRange = sceneGraph.getTimeRange(this);\n\n    const stateTimeRange = timeRange.state.value;\n    const dataTimeRange = data.timeRange;\n\n    if (\n      stateTimeRange.from.unix() === dataTimeRange.from.unix() &&\n      stateTimeRange.to.unix() === dataTimeRange.to.unix()\n    ) {\n      return false;\n    }\n    writeSceneLog('SceneQueryRunner', 'Data time range is stale');\n    return true;\n  }\n\n  private _onDeactivate(): void {\n    if (this._querySub) {\n      this._querySub.unsubscribe();\n      this._querySub = undefined;\n    }\n\n    if (this._dataLayersSub) {\n      this._dataLayersSub.unsubscribe();\n      this._dataLayersSub = undefined;\n    }\n\n    this._timeSub?.unsubscribe();\n    this._timeSub = undefined;\n    this._timeSubRange = undefined;\n    this._adhocFiltersVar = undefined;\n    this._groupByVar = undefined;\n    this._variableValueRecorder.recordCurrentDependencyValuesForSceneObject(this);\n  }\n\n  public setContainerWidth(width: number) {\n    // If we don't have a width we should run queries\n    if (!this._containerWidth && width > 0) {\n      this._containerWidth = width;\n\n      // If we don't have maxDataPoints specifically set and maxDataPointsFromWidth is true\n      if (this.state.maxDataPointsFromWidth && !this.state.maxDataPoints) {\n        // As this is called from render path we need to wait for next tick before running queries\n        setTimeout(() => {\n          if (this.isActive && !this.state._hasFetchedData) {\n            this.runQueries();\n          }\n        }, 0);\n      }\n    } else {\n      // if the updated container width is bigger than 0 let's remember the width until next query issue\n      if (width > 0) {\n        this._containerWidth = width;\n      }\n    }\n  }\n\n  public isDataReadyToDisplay() {\n    return Boolean(this.state._hasFetchedData);\n  }\n\n  private subscribeToTimeRangeChanges(timeRange: SceneTimeRangeLike) {\n    if (this._timeSubRange === timeRange) {\n      // Nothing to do, already subscribed\n      return;\n    }\n\n    if (this._timeSub) {\n      this._timeSub.unsubscribe();\n    }\n\n    this._timeSubRange = timeRange;\n    this._timeSub = timeRange.subscribeToState(() => {\n      this.runWithTimeRange(timeRange);\n    });\n  }\n\n  public runQueries() {\n    const timeRange = sceneGraph.getTimeRange(this);\n    if(this.isQueryModeAuto()){\n      this.subscribeToTimeRangeChanges(timeRange);\n    }\n\n    this.runWithTimeRange(timeRange);\n  }\n\n  private getMaxDataPoints() {\n    if (this.state.maxDataPoints) {\n      return this.state.maxDataPoints;\n    }\n\n    return this.state.maxDataPointsFromWidth ? this._containerWidth ?? 500 : 500;\n  }\n\n  public cancelQuery() {\n    this._querySub?.unsubscribe();\n\n    if (this._dataLayersSub) {\n      this._dataLayersSub.unsubscribe();\n      this._dataLayersSub = undefined;\n    }\n\n    this.setState({\n      data: { ...this.state.data!, state: LoadingState.Done },\n    });\n  }\n\n  private async runWithTimeRange(timeRange: SceneTimeRangeLike) {\n    // If no maxDataPoints specified we might need to wait for container width to be set from the outside\n    if (!this.state.maxDataPoints && this.state.maxDataPointsFromWidth && !this._containerWidth) {\n      return;\n    }\n\n    // If data layers subscription doesn't exist, create one\n    if (!this._dataLayersSub) {\n      this._handleDataLayers();\n    }\n\n    // Cancel any running queries\n    this._querySub?.unsubscribe();\n\n    // Skip executing queries if variable dependency is in loading state\n    if (this._variableDependency.hasDependencyInLoadingState()) {\n      writeSceneLog('SceneQueryRunner', 'Variable dependency is in loading state, skipping query execution');\n      this.setState({ data: { ...(this.state.data ?? emptyPanelData), state: LoadingState.Loading } });\n      return;\n    }\n\n    const { queries } = this.state;\n\n    // Simple path when no queries exist\n    if (!queries?.length) {\n      this._setNoDataState();\n      return;\n    }\n\n    try {\n      const datasource = this.state.datasource ?? findFirstDatasource(queries);\n      const ds = await getDataSource(datasource, this._scopedVars);\n\n      this.findAndSubscribeToAdHocFilters(datasource?.uid);\n\n      const runRequest = getRunRequest();\n      const { primary, secondaries, processors } = this.prepareRequests(timeRange, ds);\n\n      writeSceneLog('SceneQueryRunner', 'Starting runRequest', this.state.key);\n\n      let stream = runRequest(ds, primary);\n\n      if (secondaries.length > 0) {\n        // Submit all secondary requests in parallel.\n        const secondaryStreams = secondaries.map((r) => runRequest(ds, r));\n        // Create the rxjs operator which will combine the primary and secondary responses\n        // by calling the correct processor functions provided by the\n        // extra request providers.\n        const op = extraQueryProcessingOperator(processors);\n        // Combine the primary and secondary streams into a single stream, and apply the operator.\n        stream = forkJoin([stream, ...secondaryStreams]).pipe(op);\n      }\n\n      stream = stream.pipe(\n        registerQueryWithController({\n          type: 'data',\n          request: primary,\n          origin: this,\n          cancel: () => this.cancelQuery(),\n        })\n      );\n\n      this._querySub = stream.subscribe(this.onDataReceived);\n    } catch (err) {\n      console.error('PanelQueryRunner Error', err);\n\n      this.onDataReceived({\n        ...emptyPanelData,\n        ...this.state.data,\n        state: LoadingState.Error,\n        errors: [toDataQueryError(err)],\n      });\n    }\n  }\n\n  public clone(withState?: Partial<QueryRunnerState>) {\n    const clone = super.clone(withState);\n\n    if (this._resultAnnotations) {\n      clone['_resultAnnotations'] = this._resultAnnotations.map((frame) => ({ ...frame }));\n    }\n\n    if (this._layerAnnotations) {\n      clone['_layerAnnotations'] = this._layerAnnotations.map((frame) => ({ ...frame }));\n    }\n\n    clone['_variableValueRecorder'] = this._variableValueRecorder.cloneAndRecordCurrentValuesForSceneObject(this);\n    clone['_containerWidth'] = this._containerWidth;\n    clone['_results'].next({ origin: this, data: this.state.data ?? emptyPanelData });\n\n    return clone;\n  }\n\n  private prepareRequests(timeRange: SceneTimeRangeLike, ds: DataSourceApi): PreparedRequests {\n    const { minInterval, queries } = this.state;\n\n    let request: DataQueryRequest<DataQueryExtended> = {\n      app: 'scenes',\n      requestId: getNextRequestId(),\n      timezone: timeRange.getTimeZone(),\n      range: timeRange.state.value,\n      interval: '1s',\n      intervalMs: 1000,\n      targets: cloneDeep(queries),\n      maxDataPoints: this.getMaxDataPoints(),\n      scopedVars: this._scopedVars,\n      startTime: Date.now(),\n      liveStreaming: this.state.liveStreaming,\n      rangeRaw: {\n        from: timeRange.state.from,\n        to: timeRange.state.to,\n      },\n      cacheTimeout: this.state.cacheTimeout,\n      queryCachingTTL: this.state.queryCachingTTL,\n      // This asks the scene root to provide context properties like app, panel and dashboardUID\n      ...getEnrichedDataRequest(this),\n    };\n\n    if (this._adhocFiltersVar) {\n      // only pass filters that have both key and value\n      // @ts-ignore (Temporary ignore until we update @grafana/data)\n      request.filters = this._adhocFiltersVar.state.filters.filter(isFilterComplete);\n    }\n\n    if (this._groupByVar) {\n      // @ts-ignore (Temporary ignore until we update @grafana/data)\n      request.groupByKeys = this._groupByVar.state.value;\n    }\n\n    request.targets = request.targets.map((query) => {\n      if (\n        !query.datasource ||\n        (query.datasource.uid !== ds.uid &&\n          !ds.meta?.mixed &&\n          isExpressionReference /* TODO: Remove this check when isExpressionReference is properly exported from grafan runtime */ &&\n          !isExpressionReference(query.datasource))\n      ) {\n        query.datasource = ds.getRef();\n      }\n      return query;\n    });\n\n    const lowerIntervalLimit = minInterval ? interpolate(this, minInterval) : ds.interval;\n    const norm = rangeUtil.calculateInterval(timeRange.state.value, request.maxDataPoints!, lowerIntervalLimit);\n\n    // make shallow copy of scoped vars,\n    // and add built in variables interval and interval_ms\n    request.scopedVars = Object.assign({}, request.scopedVars, {\n      __interval: { text: norm.interval, value: norm.interval },\n      __interval_ms: { text: norm.intervalMs.toString(), value: norm.intervalMs },\n    });\n\n    request.interval = norm.interval;\n    request.intervalMs = norm.intervalMs;\n\n    // If there are any extra request providers, we need to add a new request for each\n    // and map the request's ID to the processor function given by the provider, to ensure that\n    // the processor is called with the correct response data.\n    const primaryTimeRange = timeRange.state.value;\n    let secondaryRequests: DataQueryRequest[] = [];\n    let secondaryProcessors = new Map();\n    for (const provider of this.getClosestExtraQueryProviders() ?? []) {\n      for (const { req, processor } of provider.getExtraQueries(request)) {\n        const requestId = getNextRequestId();\n        secondaryRequests.push({ ...req, requestId });\n        secondaryProcessors.set(requestId, processor ?? passthroughProcessor);\n      }\n    }\n    request.range = primaryTimeRange;\n    return { primary: request, secondaries: secondaryRequests, processors: secondaryProcessors };\n  }\n\n  private onDataReceived = (data: PanelData) => {\n    // Will combine annotations from SQR queries (frames with meta.dataTopic === DataTopic.Annotations)\n    const preProcessedData = preProcessPanelData(data, this.state.data);\n\n    // Save query annotations\n    this._resultAnnotations = data.annotations;\n\n    // Will combine annotations & alert state from data layer providers\n    const dataWithLayersApplied = this._combineDataLayers(preProcessedData);\n\n    let hasFetchedData = this.state._hasFetchedData;\n\n    if (!hasFetchedData && preProcessedData.state !== LoadingState.Loading) {\n      hasFetchedData = true;\n    }\n\n    this.setState({ data: dataWithLayersApplied, _hasFetchedData: hasFetchedData });\n    this._results.next({ origin: this, data: dataWithLayersApplied });\n  };\n\n  private _combineDataLayers(data: PanelData) {\n    if (this._layerAnnotations && this._layerAnnotations.length > 0) {\n      data.annotations = (data.annotations || []).concat(this._layerAnnotations);\n    }\n\n    if (this.state.data && this.state.data.alertState) {\n      data.alertState = this.state.data.alertState;\n    }\n\n    return data;\n  }\n\n  private _setNoDataState() {\n    if (this.state.data !== emptyPanelData) {\n      this.setState({ data: emptyPanelData });\n    }\n  }\n\n  /**\n   * Walk up the scene graph and find any ExtraQueryProviders.\n   *\n   * This will return an array of the closest provider of each type.\n   */\n  private getClosestExtraQueryProviders(): Array<ExtraQueryProvider<any>> {\n    // Maintain a map from provider constructor to provider object. The constructor\n    // is used as a unique key for each class, to ensure we have no more than one\n    // type of each type of provider.\n    const found = new Map();\n    if (!this.parent) {\n      return [];\n    }\n    getClosest(this.parent, (s) => {\n      if (isExtraQueryProvider(s) && !found.has(s.constructor)) {\n        found.set(s.constructor, s);\n      }\n      s.forEachChild((child) => {\n        if (isExtraQueryProvider(child) && !found.has(child.constructor)) {\n          found.set(child.constructor, child);\n        }\n      });\n      // Always return null so that the search continues to the top of\n      // the scene graph.\n      return null;\n    });\n    return Array.from(found.values());\n  }\n\n  /**\n   * Walk up scene graph and find the closest filterset with matching data source\n   */\n  private findAndSubscribeToAdHocFilters(uid: string | undefined) {\n    const filtersVar = findActiveAdHocFilterVariableByUid(uid);\n\n    if (this._adhocFiltersVar !== filtersVar) {\n      this._adhocFiltersVar = filtersVar;\n      this._updateExplicitVariableDependencies();\n    }\n\n    const groupByVar = findActiveGroupByVariablesByUid(uid);\n    if (this._groupByVar !== groupByVar) {\n      this._groupByVar = groupByVar;\n      this._updateExplicitVariableDependencies();\n    }\n  }\n\n  private _updateExplicitVariableDependencies() {\n    const explicitDependencies: string[] = [];\n\n    if (this._adhocFiltersVar) {\n      explicitDependencies.push(this._adhocFiltersVar.state.name);\n    }\n\n    if (this._groupByVar) {\n      explicitDependencies.push(this._groupByVar.state.name);\n    }\n\n    this._variableDependency.setVariableNames(explicitDependencies);\n  }\n\n  private isQueryModeAuto(): boolean {\n    return (this.state.runQueriesMode ?? 'auto') === 'auto'\n  }\n}\n\nexport function findFirstDatasource(targets: DataQuery[]): DataSourceRef | undefined {\n  return targets.find((t) => t.datasource !== null)?.datasource ?? undefined;\n}\n\nfunction allFramesEmpty(frames?: DataFrame[]) {\n  if (!frames) {\n    return true;\n  }\n\n  for (let i = 0; i < frames.length; i++) {\n    if (frames[i].length > 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"],"names":["_a"],"mappings":"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"}