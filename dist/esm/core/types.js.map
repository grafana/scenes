{"version":3,"file":"types.js","sources":["../../../src/core/types.ts"],"sourcesContent":["import React from 'react';\nimport { MonoTypeOperatorFunction, Observable, Unsubscribable } from 'rxjs';\n\nimport {\n  BusEvent,\n  BusEventHandler,\n  BusEventType,\n  DataFrame,\n  DataQueryRequest,\n  DataSourceGetTagKeysOptions,\n  DataSourceGetTagValuesOptions,\n  DataTransformContext,\n  PanelData,\n  TimeRange,\n} from '@grafana/data';\nimport { DataQuery, DataTopic, TimeZone } from '@grafana/schema';\n\nimport { SceneVariableDependencyConfigLike, SceneVariables } from '../variables/types';\nimport { SceneObjectRef } from './SceneObjectRef';\n\nexport interface SceneObjectState {\n  key?: string;\n  $timeRange?: SceneTimeRangeLike;\n  $data?: SceneDataProvider;\n  $variables?: SceneVariables;\n  /**\n   * @experimental\n   * Can be used to add extra behaviors to a scene object.\n   * These are activated when the their parent scene object is activated.\n   */\n  $behaviors?: Array<SceneObject | SceneStatelessBehavior>;\n}\n\nexport interface SceneLayoutChildOptions {\n  width?: number | string;\n  height?: number | string;\n  xSizing?: 'fill' | 'content';\n  ySizing?: 'fill' | 'content';\n  x?: number;\n  y?: number;\n  minWidth?: number | string;\n  minHeight?: number | string;\n  isDraggable?: boolean;\n  isResizable?: boolean;\n}\n\nexport interface SceneComponentProps<T> {\n  model: T;\n}\n\nexport type SceneComponent<TModel> = (props: SceneComponentProps<TModel>) => React.ReactElement | null;\n\nexport interface SceneDataState extends SceneObjectState {\n  data?: PanelData;\n}\n\nexport interface SceneObject<TState extends SceneObjectState = SceneObjectState> {\n  /** The current state */\n  readonly state: TState;\n\n  /** True when there is a React component mounted for this Object */\n  readonly isActive: boolean;\n\n  /** SceneObject parent */\n  readonly parent?: SceneObject;\n\n  /** This abtractions declares what variables the scene object depends on and how to handle when they change value. **/\n  readonly variableDependency?: SceneVariableDependencyConfigLike;\n\n  /** This abstraction declares URL sync dependencies of a scene object. **/\n  readonly urlSync?: SceneObjectUrlSyncHandler;\n\n  /** Subscribe to state changes */\n  subscribeToState(handler: SceneStateChangedHandler<TState>): Unsubscribable;\n\n  /** Subscribe to a scene event */\n  subscribeToEvent<T extends BusEvent>(typeFilter: BusEventType<T>, handler: BusEventHandler<T>): Unsubscribable;\n\n  /** Publish an event and optionally bubble it up the scene */\n  publishEvent(event: BusEvent, bubble?: boolean): void;\n\n  /** Utility hook that wraps useObservable. Used by React components to subscribes to state changes */\n  useState(): TState;\n\n  /** How to modify state */\n  setState(state: Partial<TState>): void;\n\n  /**\n   * Called when the Component is mounted. This will also activate any $data, $variables or $timeRange scene object on this level.\n   * Don't override this in your custom SceneObjects, instead use addActivationHandler from the constructor.\n   **/\n  activate(): CancelActivationHandler;\n\n  /** Get the scene root */\n  getRoot(): SceneObject;\n\n  /** Returns a deep clone this object and all its children */\n  clone(state?: Partial<TState>): this;\n\n  /** A React component to use for rendering the object */\n  Component(props: SceneComponentProps<SceneObject<TState>>): React.ReactElement | null;\n\n  /** Force a re-render, should only be needed when variable values change */\n  forceRender(): void;\n\n  /** Returns a SceneObjectRef that will resolve to this object */\n  getRef(): SceneObjectRef<this>;\n\n  /**\n   * Allows external code to register code that is executed on activate and deactivate. This allow you\n   * to wire up scene objects that need to respond to state changes in other objects from the outside.\n   **/\n  addActivationHandler(handler: SceneActivationHandler): void;\n\n  /**\n   * Loop through state and call callback for each direct child scene object.\n   * Checks 1 level deep properties and arrays. So a scene object hidden in a nested plain object will not be detected.\n   */\n  forEachChild(callback: (child: SceneObject) => void): void;\n}\n\nexport type SceneActivationHandler = () => SceneDeactivationHandler | void;\nexport type SceneDeactivationHandler = () => void;\n\n/**\n * Function returned by activate() that when called will deactivate the object if it's the last activator\n **/\nexport type CancelActivationHandler = () => void;\n\nexport interface SceneLayoutState extends SceneObjectState {\n  children: SceneObject[];\n}\n\nexport interface SceneLayout<T extends SceneLayoutState = SceneLayoutState> extends SceneObject<T> {\n  isDraggable(): boolean;\n  getDragClass?(): string;\n  getDragClassCancel?(): string;\n}\n\nexport interface SceneTimeRangeState extends SceneObjectState {\n  from: string;\n  to: string;\n  fiscalYearStartMonth?: number;\n  value: TimeRange;\n  timeZone?: TimeZone;\n  /** weekStart will change the global date locale so having multiple different weekStart values is not supported  */\n  weekStart?: string;\n  /**\n   * @internal\n   * To enable feature parity with the old time range picker, not sure if it will be kept.\n   * Override the now time by entering a time delay. Use this option to accommodate known delays in data aggregation to avoid null values.\n   * */\n  UNSAFE_nowDelay?: string;\n\n  refreshOnActivate?: {\n    /**\n     * When set, the time range will invalidate relative ranges after the specified interval has elapsed\n     */\n    afterMs?: number;\n    /**\n     * When set, the time range will invalidate relative ranges after the specified percentage of the current interval has elapsed.\n     * If both invalidate values are set, the smaller value will be used for the given interval.\n     */\n    percent?: number;\n  };\n}\n\nexport interface SceneTimeRangeLike extends SceneObject<SceneTimeRangeState> {\n  onTimeZoneChange(timeZone: TimeZone): void;\n  onTimeRangeChange(timeRange: TimeRange): void;\n  onRefresh(): void;\n  getTimeZone(): TimeZone;\n}\n\nexport function isSceneObject(obj: any): obj is SceneObject {\n  return obj.useState !== undefined;\n}\n\nexport interface SceneObjectWithUrlSync extends SceneObject {\n  getUrlState(): SceneObjectUrlValues;\n  updateFromUrl(values: SceneObjectUrlValues): void;\n  shouldCreateHistoryStep?(values: SceneObjectUrlValues): boolean;\n}\n\nexport interface SceneObjectUrlSyncHandler {\n  getKeys(): string[];\n  getUrlState(): SceneObjectUrlValues;\n  updateFromUrl(values: SceneObjectUrlValues): void;\n  shouldCreateHistoryStep?(values: SceneObjectUrlValues): boolean;\n}\n\nexport interface DataRequestEnricher {\n  // Return partial data query request that will be merged with the original request provided by SceneQueryRunner\n  enrichDataRequest(source: SceneObject): Partial<DataQueryRequest> | null;\n}\n\nexport interface FiltersRequestEnricher {\n  // Return partial getTagKeys or getTagValues query request that will be merged with the original request provided by ad hoc or group by variable\n  enrichFiltersRequest(\n    source: SceneObject\n  ): Partial<DataSourceGetTagKeysOptions | DataSourceGetTagValuesOptions> | null;\n}\n\nexport function isDataRequestEnricher(obj: any): obj is DataRequestEnricher {\n  return 'enrichDataRequest' in obj;\n}\n\nexport function isFiltersRequestEnricher(obj: any): obj is FiltersRequestEnricher {\n  return 'enrichFiltersRequest' in obj;\n}\n\nexport type SceneObjectUrlValue = string | string[] | undefined | null;\nexport type SceneObjectUrlValues = Record<string, SceneObjectUrlValue>;\n\nexport type CustomTransformOperator = (context: DataTransformContext) => MonoTypeOperatorFunction<DataFrame[]>;\nexport type CustomTransformerDefinition =\n  | { operator: CustomTransformOperator; topic: DataTopic }\n  | CustomTransformOperator;\nexport type SceneStateChangedHandler<TState> = (newState: TState, prevState: TState) => void;\n\nexport type DeepPartial<T> = {\n  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];\n};\n\nexport interface SceneDataProviderResult {\n  data: PanelData;\n  origin: SceneDataProvider;\n}\n\nexport interface SceneDataProvider<T extends SceneObjectState = SceneDataState> extends SceneObject<T> {\n  setContainerWidth?: (width: number) => void;\n  isDataReadyToDisplay?: () => boolean;\n  cancelQuery?: () => void;\n  getResultsStream(): Observable<SceneDataProviderResult>;\n}\n\nexport interface SceneDataLayerProviderState extends SceneDataState {\n  name: string;\n  description?: string;\n  isEnabled?: boolean;\n  isHidden?: boolean;\n}\n\nexport interface SceneDataLayerProvider extends SceneDataProvider<SceneDataLayerProviderState> {\n  isDataLayer: true;\n}\n\nexport function isDataLayer(obj: SceneObject): obj is SceneDataLayerProvider {\n  return 'isDataLayer' in obj;\n}\n\nexport interface DataLayerFilter {\n  panelId: number;\n}\n\nexport interface SceneStatelessBehavior<T extends SceneObject = any> {\n  (sceneObject: T): CancelActivationHandler | void;\n}\n\nexport type ControlsLayout = 'horizontal' | 'vertical';\n\nexport interface UseStateHookOptions {\n  /**\n   * For some edge cases other scene objects want to subscribe to scene object state for objects\n   * that are not active, or whose main React Component can be un-mounted. Set this to true\n   * to keep the scene object active even if the React component is unmounted.\n   *\n   * Normally you would not need this but this can be useful in some edge cases.\n   *\n   * @experimental\n   */\n  shouldActivateOrKeepAlive?: boolean;\n}\n\nexport interface SceneDataQuery extends DataQuery {\n  [key: string]: any;\n\n  // Opt this query out of time window comparison\n  timeRangeCompare?: boolean;\n}\n\nexport interface SceneUrlSyncOptions {\n  /**\n   * This will update the url to contain all scene url state\n   * when the scene is initialized. Important for browser history \"back\" actions.\n   */\n  updateUrlOnInit?: boolean;\n  /**\n   * This is only supported by some objects if they implement\n   * shouldCreateHistoryStep where they can control what changes\n   * url changes should add a new browser history entry.\n   */\n  createBrowserHistorySteps?: boolean;\n}\n"],"names":[],"mappings":"AA8KO,SAAS,cAAc,GAA8B,EAAA;AAC1D,EAAA,OAAO,IAAI,QAAa,KAAA,KAAA,CAAA,CAAA;AAC1B,CAAA;AA2BO,SAAS,sBAAsB,GAAsC,EAAA;AAC1E,EAAA,OAAO,mBAAuB,IAAA,GAAA,CAAA;AAChC,CAAA;AAEO,SAAS,yBAAyB,GAAyC,EAAA;AAChF,EAAA,OAAO,sBAA0B,IAAA,GAAA,CAAA;AACnC,CAAA;AAsCO,SAAS,YAAY,GAAiD,EAAA;AAC3E,EAAA,OAAO,aAAiB,IAAA,GAAA,CAAA;AAC1B;;;;"}