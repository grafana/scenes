{"version":3,"file":"sceneGraph.js","sources":["../../../../src/core/sceneGraph/sceneGraph.ts"],"sourcesContent":["import { ScopedVars } from '@grafana/data';\nimport { EmptyDataNode, EmptyVariableSet } from '../../variables/interpolation/defaults';\n\nimport { sceneInterpolator } from '../../variables/interpolation/sceneInterpolator';\nimport { VariableCustomFormatterFn, SceneVariables } from '../../variables/types';\n\nimport { isDataLayer, SceneDataLayerProvider, SceneDataProvider, SceneLayout, SceneObject } from '../types';\nimport { lookupVariable } from '../../variables/lookupVariable';\nimport { getClosest } from './utils';\nimport { SceneQueryControllerLike, isQueryController } from '../../behaviors/SceneQueryController';\nimport { VariableInterpolation } from '@grafana/runtime';\nimport { QueryVariable } from '../../variables/variants/query/QueryVariable';\nimport { UrlSyncManagerLike } from '../../services/UrlSyncManager';\n\n/**\n * Get the closest node with variables\n */\nexport function getVariables(sceneObject: SceneObject): SceneVariables {\n  return getClosest(sceneObject, (s) => s.state.$variables) ?? EmptyVariableSet;\n}\n\n/**\n * Will walk up the scene object graph to the closest $data scene object\n */\nexport function getData(sceneObject: SceneObject): SceneDataProvider {\n  return getClosest(sceneObject, (s) => s.state.$data) ?? EmptyDataNode;\n}\n\nfunction isSceneLayout(s: SceneObject): s is SceneLayout {\n  return 'isDraggable' in s;\n}\n\n/**\n * Will walk up the scene object graph to the closest $layout scene object\n */\nexport function getLayout(scene: SceneObject): SceneLayout | null {\n  const parent = getClosest(scene, (s) => (isSceneLayout(s) ? s : undefined));\n  if (parent) {\n    return parent;\n  }\n\n  return null;\n}\n\n/**\n * Interpolates the given string using the current scene object as context.   *\n *\n * Note: the interpolations array will be mutated by adding information about variables that\n * have been interpolated during replacement. Variables that were specified in the target but not found in\n * the list of available variables are also added to the array. See {@link VariableInterpolation} for more details.\n *\n * @param {VariableInterpolation[]} interpolations an optional array that is updated with interpolated variables.\n */\nexport function interpolate(\n  sceneObject: SceneObject,\n  value: string | undefined | null,\n  scopedVars?: ScopedVars,\n  format?: string | VariableCustomFormatterFn,\n  interpolations?: VariableInterpolation[]\n): string {\n  if (value === '' || value == null) {\n    return '';\n  }\n\n  return sceneInterpolator(sceneObject, value, scopedVars, format, interpolations);\n}\n\n/**\n * Checks if the variable is currently loading or waiting to update.\n * It also returns true if a dependency of the variable is loading.\n *\n * For example if C depends on variable B which depends on variable A and A is loading this returns true for variable C and B.\n */\nexport function hasVariableDependencyInLoadingState(sceneObject: SceneObject) {\n  if (!sceneObject.variableDependency) {\n    return false;\n  }\n\n  for (const name of sceneObject.variableDependency.getNames()) {\n    // This is for backwards compability. In the old architecture query variables could reference itself in a query without breaking.\n    if (sceneObject instanceof QueryVariable && sceneObject.state.name === name) {\n      console.warn('Query variable is referencing itself');\n      continue;\n    }\n\n    const variable = lookupVariable(name, sceneObject);\n    if (!variable) {\n      continue;\n    }\n\n    const set = variable.parent as SceneVariables;\n    if (set.isVariableLoadingOrWaitingToUpdate(variable)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction findObjectInternal(\n  scene: SceneObject,\n  check: (obj: SceneObject) => boolean,\n  alreadySearchedChild?: SceneObject,\n  shouldSearchUp?: boolean\n): SceneObject | null {\n  if (check(scene)) {\n    return scene;\n  }\n\n  let found: SceneObject | null = null;\n\n  scene.forEachChild((child) => {\n    if (child === alreadySearchedChild) {\n      return;\n    }\n\n    let maybe = findObjectInternal(child, check);\n    if (maybe) {\n      found = maybe;\n    }\n  });\n\n  if (found) {\n    return found;\n  }\n\n  if (shouldSearchUp && scene.parent) {\n    return findObjectInternal(scene.parent, check, scene, true);\n  }\n\n  return null;\n}\n\n/**\n * Returns a scene object from the scene graph with the requested key.\n *\n * Throws error if no key-matching scene object found.\n */\nexport function findByKey(sceneObject: SceneObject, key: string) {\n  const found = findObject(sceneObject, (sceneToCheck) => {\n    return sceneToCheck.state.key === key;\n  });\n  if (!found) {\n    throw new Error('Unable to find scene with key ' + key);\n  }\n  return found;\n}\n\n/**\n * Returns a scene object from the scene graph with the requested key and type.\n *\n * Throws error if no key-matching scene object found.\n * Throws error if the given type does not match.\n */\nexport function findByKeyAndType<TargetType extends SceneObject>(\n  sceneObject: SceneObject,\n  key: string,\n  targetType: { new (...args: never[]): TargetType }\n) {\n  const found = findObject(sceneObject, (sceneToCheck) => {\n    return sceneToCheck.state.key === key;\n  });\n  if (!found) {\n    throw new Error('Unable to find scene with key ' + key);\n  }\n  if (!(found instanceof targetType)) {\n    throw new Error(`Found scene object with key ${key} does not match type ${targetType.name}`);\n  }\n  return found;\n}\n\n/**\n * This will search the full scene graph, starting with the scene node passed in, then walking up the parent chain. *\n */\nexport function findObject(scene: SceneObject, check: (obj: SceneObject) => boolean): SceneObject | null {\n  return findObjectInternal(scene, check, undefined, true);\n}\n\n/**\n * This will search down the full scene graph, looking for objects that match the provided predicate.\n */\nexport function findAllObjects(scene: SceneObject, check: (obj: SceneObject) => boolean): SceneObject[] {\n  const found: SceneObject[] = [];\n\n  scene.forEachChild((child) => {\n    if (check(child)) {\n      found.push(child);\n    }\n\n    found.push(...findAllObjects(child, check));\n  });\n\n  return found;\n}\n\n/**\n * Will walk up the scene object graph up until the root and collect all SceneDataLayerProvider objects.\n * When localOnly set to true, it will only collect the closest layers.\n */\nexport function getDataLayers(sceneObject: SceneObject, localOnly = false): SceneDataLayerProvider[] {\n  let currentLevel: SceneObject | undefined = sceneObject;\n  let collected: SceneDataLayerProvider[] = [];\n\n  while (currentLevel) {\n    const dataProvider = currentLevel.state.$data;\n    if (!dataProvider) {\n      currentLevel = currentLevel.parent;\n      continue;\n    }\n\n    // Check if data layer exists nested inside another data provider\n    if (isDataLayer(dataProvider)) {\n      collected = collected.concat(dataProvider);\n    } else {\n      if (dataProvider.state.$data && isDataLayer(dataProvider.state.$data)) {\n        collected = collected.concat(dataProvider.state.$data);\n      }\n    }\n\n    if (localOnly && collected.length > 0) {\n      break;\n    }\n\n    currentLevel = currentLevel.parent;\n  }\n\n  return collected;\n}\n\ninterface SceneType<T> extends Function {\n  new (...args: never[]): T;\n}\n\n/**\n * A utility function to find the closest ancestor of a given type. This function expects\n * to find it and will throw an error if it does not.\n */\nexport function getAncestor<ParentType>(\n  sceneObject: SceneObject,\n  ancestorType: SceneType<ParentType>\n): ParentType {\n  let parent: SceneObject | undefined = sceneObject;\n\n  while (parent) {\n    if (parent instanceof ancestorType) {\n      return parent;\n    }\n    parent = parent.parent;\n  }\n\n  if (!parent) {\n    throw new Error('Unable to find parent of type ' + ancestorType.name);\n  }\n\n  return parent as ParentType;\n}\n\n/**\n * This will search down the full scene graph, looking for objects that match the provided descendentType type.\n */\nexport function findDescendents<T extends SceneObject>(scene: SceneObject, descendentType: SceneType<T>) {\n  function isDescendentType(scene: SceneObject): scene is T {\n    return scene instanceof descendentType;\n  }\n\n  const targetScenes = findAllObjects(scene, isDescendentType);\n  return targetScenes.filter(isDescendentType);\n}\n\n/**\n * Returns the closest query controller undefined if none found\n */\nexport function getQueryController(sceneObject: SceneObject): SceneQueryControllerLike | undefined {\n  let parent: SceneObject | undefined = sceneObject;\n\n  while (parent) {\n    if (parent.state.$behaviors) {\n      for (const behavior of parent.state.$behaviors) {\n        if (isQueryController(behavior)) {\n          return behavior;\n        }\n      }\n    }\n    parent = parent.parent;\n  }\n\n  return undefined;\n}\n\n/**\n * Returns the closest SceneObject that has a state property with the\n * name urlSyncManager that is of type UrlSyncManager\n */\nexport function getUrlSyncManager(sceneObject: SceneObject): UrlSyncManagerLike | undefined {\n  let parent: SceneObject | undefined = sceneObject;\n\n  while (parent) {\n    if ('urlSyncManager' in parent.state) {\n      return parent.state.urlSyncManager as UrlSyncManagerLike;\n    }\n    parent = parent.parent;\n  }\n\n  return undefined;\n}\n"],"names":["scene"],"mappings":"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"}